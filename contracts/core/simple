// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Votes.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/utils/Counters.sol";
import "./../interfaces/IFigurePrintOracle.sol";
import "./../interfaces/IUserIdentityNFT.sol";
import "./../libraries/OracleHelper.sol";
import "./../libraries/UserIdentityNFT.sol";

contract UserIdentityNFT is ERC721URIStorage, ReentrancyGuard, ERC721Votes, IUserIdentityNFT {
    using Counters for Counters.Counter;
    Counters.Counter private idCount;
    address private figureprintOracle;
    bytes32 public constant CLAME_USERID_VOUCHER =
        keccak256("createUserId(string uri,bytes userId,bytes fingerPrint)");

    // "NFTVoucher(uint256 tokenId,string uri,address currency,uint256 minPrice,bool isFixedPrice)"

    constructor(
        string memory name,
        string memory symbol,
        string memory signingDomain,
        string memory signatureVersion
    ) ERC721(name, symbol) EIP712(signingDomain, signatureVersion) {}

    // The functions below are overrides required by Solidity.

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal override(ERC721, ERC721Votes) {
        super._afterTokenTransfer(from, to, firstTokenId, batchSize);
    }

    /// @notice Redeems an NFTVoucher for an actual NFT, creating it in the process.

    function redeem(UserIdVoucher calldata voucher) public {
        idCount.increment();
        uint256 tokenId = idCount.current();
        _mint(msg.sender, tokenId);
        _setTokenURI(tokenId, voucher.uri);
        emit IdVerifedAndIssued(voucher.userId, msg.sender);
    }

    function checkBalance() public {
        if (balanceOf(msg.sender) > 0) {
            revert UserIdentityNFT__UserIdAlreadyIssued(msg.sender);
        }
    }

    function transferFrom(
        address from,
        address /*to*/,
        uint256 tokenId
    ) public virtual override(ERC721) {
        // require(true, "Not Allow to Transfer Token");
        revert UserIdentityNFT__TransferNoAllowed(tokenId, from);
    }

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        // burnUserRecord call but first check the user is owner of the NFT

        super._burn(tokenId);
    }

    function tokenURI(
        uint256 tokenId
    ) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function getFingerPrintAddress() public view returns (address) {
        return address(figureprintOracle);
    }

    function getIdCount() public view returns (uint256) {
        return idCount.current();
    }
}
